-- JsonTool
-- Tool for exporting and importing information about in-game objects in JSON-format.

-- constants
version = '2.2.0'
url = 'https://github.com/indvd00m/json-tool'
configTabName = 'json.conf'
dataTabName = 'json.data'
exportBackupTabNamePrefix = 'json.exp.backup'
importBackupTabNamePrefix = 'json.imp.backup'
tabsColor = 'Grey'
exportButtonLabel = 'Export'
exportButtonTooltip = 'Export information about in-game objects to tab "' ..
    dataTabName .. '" in JSON-format'
importButtonLabel = 'Import'
importButtonTooltip = 'Import information about in-game objects from tab "' ..
    dataTabName .. '" in JSON-format'
mainColor = {102/255, 153/255, 153/255}
processColor = {255/255, 102/255, 102/255}
defaultButtonColor = {255/255, 255/255, 255/255}
defaultConfig = {
    exportEmptyData = false,
    createExportBackups = true,
    createImportBackups = true,
    processContainers = true,
    takeRelativePosition = {2, 0, 2}
}
takeErrorTimeoutSeconds = 10

-- variables
config = {}
data = nil
async = {
    inProcess = false,
    processedGuids = nil,
    stack = nil,
    maxStackLength = 0,
    progress = 0,
    progressCount = nil,
    objectProcessor = nil,
    finishListener = nil,
    count = 0
}

-- code
function onSave()
    local persistence = {
        config = config
    }
    local json = JSON.encode(persistence)
    return json
end

function onLoad(savedState)
    if savedState ~= nil and savedState ~= "" then
        local persistence = JSON.decode(savedState)
        applyConfig(persistence.config, true)
    else
        config = clone(defaultConfig)
    end

    updateForBackwardCompatibility()

    createButtons()
    syncTabs()

    -- on load always force write config to tab
    writeConfigToTab(getTabByName(configTabName))

    self.setName('JsonTool')
    self.setDescription('\z
        JsonTool is a tool for exporting and importing information about \z
        in-game objects in JSON-format. JsonTool works with Notebook tabs \z
        for all actions. All needed tabs would created automatically. \z
        Exporting and importing processes use tab "' .. dataTabName .. '" for \z
        saving or getting information in  JSON-format. Before every importing \z
        and exporting JsonTool would save  backup to tabs with prefix \z
        "' .. exportBackupTabNamePrefix .. '" and \z
        "' .. importBackupTabNamePrefix .. '". Export and import \z
        configuration is saved in tab "' .. configTabName .. '"". Before \z
        every import and export configuration would be read from this tab. \z
        \n\nNote: sometimes Tabletop Simulator incorrectly works with \z
        Notebook tabs. If you did not see any data in created tabs try to \z
        remove all tabs and then run Export or Import again.\z
        \n\nVersion ' .. version .. '. \n\n' .. url)
    self.setColorTint(mainColor)
end

function updateForBackwardCompatibility()
    -- insert new config options if need
    for option, defaultValue in pairs(defaultConfig) do
        if (config[option] == nil) then
            config[option] = defaultValue
        end
    end
end

function syncTabs()
    local configTab = getTabByName(configTabName)
    if (configTab == nil) then
        addNotebookTab({
            title = configTabName,
            body  = '',
            color = tabsColor
        })
        configTab = getTabByName(configTabName)
        writeConfigToTab(configTab)
    else
        if (readConfigFromTab(configTab) == true) then
            writeConfigToTab(configTab)
        end
    end

    local dataTab = getTabByName(dataTabName)
    if (dataTab == nil) then
        addNotebookTab({
            title = dataTabName,
            body  = '',
            color = tabsColor
        })
        dataTab = getTabByName(dataTabName)
        writeDataToTab(dataTab, {})
    end
end

function getTabByName(tabName)
    local tabs = getNotebookTabs()
    for index, tab in pairs(tabs) do
        if tab.title == tabName then
            return tab
        end
    end
    return nil
end

function readConfigFromTab(configTab)
    if (configTab == nil) then
        return false
    end
    local tabContent = configTab.body
    if (tabContent == nil) then
        return false
    end
    local userConfig = JSON.decode(tabContent)
    return applyConfig(userConfig, false)
end

function applyConfig(newConfig, allowIncorrectConfig)
    local correctConfig = true
    local tmpConfig = {}
    for option, defaultValue in pairs(defaultConfig) do
        local newValue = nil
        if (newConfig != nil) then
            newValue = newConfig[option]
        end
        if (newValue == nil) then
            correctConfig = false
            tmpConfig[option] = defaultValue
        else
            tmpConfig[option] = newValue
        end
    end
    if (correctConfig == true or allowIncorrectConfig) then
        config = tmpConfig
        return true
    else
        return false
    end
end

function writeConfigToTab(configTab)
    local tabContent = JSON.encode_pretty(config)
    editNotebookTab({
        index = configTab.index,
        title = configTabName,
        body  = tabContent,
        color = tabsColor
    })
end

function readDataFromTab(dataTab)
    if (dataTab == nil) then
        return nil
    end
    local tabContent = dataTab.body
    if (tabContent == nil) then
        return false
    end
    local data = JSON.decode(tabContent)
    return data
end

function writeDataToTab(dataTab, data)
    local tabContent = JSON.encode_pretty(data)
    editNotebookTab({
        index = dataTab.index,
        title = dataTabName,
        body  = tabContent,
        color = tabsColor
    })
end

function exportData()
    if (async.inProcess == true) then
        print('WARN: async task already started')
        return
    end
    print('Start exporting...')

    syncTabs()

    if (config.createExportBackups == true) then
        local dataTab = getTabByName(dataTabName)
        local tabName = createTabBackup(dataTab, exportBackupTabNamePrefix)
        print('Data backuped to tab "' .. tabName .. '".')
    else
        print('Backup is disabled.')
    end

    asyncExportStart()
end

function asyncExportStart()
    print('Export started.')
    data = {}

    asyncStart(exportObjectToDataIfNeed, asyncExportStop)
end

function asyncExportStop(count)
    table.sort(data, objectsComparator)

    local dataTab = getTabByName(dataTabName)
    writeDataToTab(dataTab, data)
    print(count .. ' in-game objects exported.')

    self.editButton({
        index          = 0,
        label          = exportButtonLabel,
        tooltip        = exportButtonTooltip
    })

    data = nil
    print('Export done.')
end

function createTabBackup(tab, tabNamePrefix)
    local tabName = tabNamePrefix .. '_' .. os.date('%Y-%m-%d_%H:%M:%S')
    addNotebookTab({
        title = tabName,
        body  = tab.body,
        color = tabsColor
    })
    return tabName
end

-- start of async
function asyncStart(asyncObjectProcessor, asyncFinishListener)
    if (async.inProcess == true) then
        print('WARN: async task already started')
        return
    end
    self.setColorTint(processColor)
    async.inProcess = true
    async.processed = {}
    async.stack = {}
    async.maxStackLength = 0
    async.progress = 0
    async.progressCount = ''
    async.objectProcessor = asyncObjectProcessor
    async.finishListener = asyncFinishListener
    async.count = 0

    local allObjects = getAllObjects()
    for index, object in pairs(allObjects) do
        asyncPush({
            guid = object.guid,
            containerGuid = nil
        })
    end
    startLuaCoroutine(self, 'asyncNext')
end

function asyncStop()
    local asyncFinishListener = async.finishListener
    local count = async.count

    async.inProcess = false
    async.processed = nil
    async.stack = nil
    async.maxStackLength = 0
    async.progress = 0
    async.progressCount = nil
    async.objectProcessor = nil
    async.finishListener = nil
    async.count = 0

    if (asyncFinishListener) then
        asyncFinishListener(count)
    end

    self.setColorTint(mainColor)
end

function asyncPush(objInfo)
    table.insert(async.stack, objInfo)
    local len = length(async.stack)
    if (len > async.maxStackLength) then
        async.maxStackLength = len
    end
    if (async.maxStackLength > 0) then
        async.progress = 1 - len / async.maxStackLength
        async.progressCount = string.format('%d/%d', async.maxStackLength - len, async.maxStackLength)
    else
        async.progress = 0
        async.progressCount = ''
    end
end

function asyncPop()
    local len = length(async.stack)
    local next = nil
    if (len > 0) then
        next = table.remove(async.stack)
    end
    if (async.maxStackLength > 0) then
        async.progress = 1 - len / async.maxStackLength
        async.progressCount = string.format('%d/%d', async.maxStackLength - len, async.maxStackLength)
    else
        async.progress = 0
        async.progressCount = ''
    end
    return next
end

function asyncPeek()
    local len = length(async.stack)
    local next = nil
    if (len > 0) then
        next = table.remove(async.stack)
        table.insert(async.stack, next)
    end
    return next
end

function asyncNext()
    if (async.inProcess == false) then
        asyncStop()
        return 1
    end
    local objectInfo = asyncPop()
    if (objectInfo == nil) then
        asyncStop()
        return 1
    end
    local object = getObjectFromGUID(objectInfo.guid)
    if (config.processContainers == true and object == nil) then
        takeFromContainer(objectInfo)
        return 1
    end
    -- object loaded
    local stackChanged = false
    if (async.processed[object.guid] == nil) then
        -- not processed
        if async.objectProcessor(object) then
            async.count = async.count + 1
        end
        async.processed[object.guid] = true
        if (config.processContainers == true) then
            stackChanged = pushNested(object, objectInfo) > 0
        end
    end
    if (
        config.processContainers == true
        and stackChanged == false
        and objectInfo.containerGuid ~= nil
    ) then
        putToContainer(object, objectInfo)
    else
        startLuaCoroutine(self, 'asyncNext')
    end
    return 1
end

function takeFromContainer(objectInfo)
    if (objectInfo.containerGuid == nil) then
        print('Trying to take object ' .. objectInfo.guid .. ' from unexisted container')
        startLuaCoroutine(self, 'asyncNext')
        return
    end
    asyncPush(objectInfo)
    local container = getObjectFromGUID(objectInfo.containerGuid)
    local position = container.positionToWorld(config.takeRelativePosition)
    container.takeObject({
        callback       = 'takedFromContainer',
        callback_owner = self,
        guid           = objectInfo.guid,
        position       = position,
        take_from_top  = true
    })
    wait(takeErrorTimeoutSeconds, function(takedGuid)
        if (async.inProcess == false) then
            return
        end
        local headInfo = asyncPeek()
        if (headInfo ~= nil and headInfo.guid == takedGuid) then
            if (async.processed[takedGuid] == nil) then
                print('Detected unworked take of object ' .. takedGuid .. ', trying to take again')
                startLuaCoroutine(self, 'asyncNext')
            end
        end
    end, objectInfo.guid)
end

function takedFromContainer(object)
    startLuaCoroutine(self, 'asyncNext')
end

function putToContainer(object, objectInfo)
    if (objectInfo.type == 'Deck') then
        putToDeck(object, objectInfo)
    else
        local container = getObjectFromGUID(objectInfo.containerGuid)
        container.putObject(object)
        startLuaCoroutine(self, 'asyncNext')
    end
end

function putToDeck(object, objectInfo)
    local deckInfo = objectInfo.deckInfo
    if (deckInfo.doubleSize == true) then
        putToDoubleSizeDeck(object, objectInfo)
    else
        local container = getObjectFromGUID(objectInfo.containerGuid)
        container.putObject(object)
        startLuaCoroutine(self, 'asyncNext')
    end
end

function putToDoubleSizeDeck(object, objectInfo)
    local deckInfo = objectInfo.deckInfo
    if (object.guid == deckInfo.element1Guid) then
        -- second time taked object
        object = getObjectFromGUID(deckInfo.element2Guid)
        objectInfo.containerGuid = deckInfo.element1Guid
        local container = getObjectFromGUID(objectInfo.containerGuid)
        container.putObject(object)
        waitObjectReplaced(container, 5, function(newObject)
            local containerInfo = asyncPeek()
            if (newObject ~= nil) then
                containerInfo.guid = newObject.guid
                containerInfo.deckInfo.deckGuid = newObject.guid
                async.processed[newObject.guid] = true
            else
                print('Waiting of replacing of object ' .. containerInfo.guid .. ' is failed.')
            end
            startLuaCoroutine(self, 'asyncNext')
        end)
    elseif (object.guid == deckInfo.element2Guid) then
        -- first time taked object
        startLuaCoroutine(self, 'asyncNext')
    end
end

function waitObjectReplaced(object, timeout, callback)
    local guid = object.guid
    local position = vectorToTable(object.getPosition())
    local rotation = vectorToTable(object.getRotation())
    waitCondition(
        conditionOr(
            conditionObjectReplaced(guid, position, rotation),
            conditionTime(timeout)
        ), function(guid, position, rotation, callback)
            local newObject = findObject(position, rotation)
            if (newObject != nil and newObject.guid == object.guid) then
                newObject = nil
            end
            callback(newObject)
        end, guid, position, rotation, callback
    )
end

function conditionObjectReplaced(guid, position, rotation)
    function conditionObjectReplacedInstance()
        local obj = findObject(position, rotation)
        local objReplaced = obj ~= nil and obj.guid ~= guid
        return objReplaced
    end
    return conditionObjectReplacedInstance
end

function findObject(position, rotation)
    local allObjects = getAllObjects()
    for index, object in pairs(allObjects) do
        local objPosition = object.getPosition()
        local objRotation = object.getRotation()
        if (
            equalsVectors(position, objPosition)
            -- and equalsVectors(rotation, objRotation)
        ) then
            return object
        end
    end
    return nil
end

function vectorToTable(v)
    return {
        x = v.x,
        y = v.y,
        z = v.z
    }
end

function equalsVectors(v1, v2)
    if (v1.x == v2.x and v1.y == v2.y and v1.z == v2.z) then
        return true
    end
    return false
end

function pushNested(object, objectInfo)
    local nestedGuids = {}
    if (object.tag == 'Bag') then
        local nestedObjectsDescs = object.getObjects()
        for index, nestedObjectDesc in pairs(nestedObjectsDescs) do
            table.insert(nestedGuids, {
                type = object.tag,
                guid = nestedObjectDesc.guid
            })
        end
    elseif (object.tag == 'Deck') then
        local nestedObjectsDescs = object.getObjects()
        local deckInfo = {
            deckGuid = object.guid,
            length = length(nestedObjectsDescs),
        }
        if deckInfo.length == 2 then
            deckInfo['doubleSize'] = true
            deckInfo['element1Guid'] = nestedObjectsDescs[1].guid
            deckInfo['element2Guid'] = nestedObjectsDescs[2].guid
        end
        for index, nestedObjectDesc in pairs(nestedObjectsDescs) do
            table.insert(nestedGuids, {
                type = object.tag,
                guid = nestedObjectDesc.guid,
                deckInfo = deckInfo
            })
        end
        objectInfo['deckInfo'] = deckInfo
    end
    local pushSize = length(nestedGuids)
    if (pushSize > 0) then
        asyncPush(objectInfo)
        for index, nestedInfo in pairs(nestedGuids) do
            local nextInfo = {
                guid = nestedInfo.guid,
                containerGuid = object.guid
            }
            for field, value in pairs(nestedInfo) do
                nextInfo[field] = value
            end
            asyncPush(nextInfo)
        end
    end
    return pushSize
end
-- end of async

-- start of wait
function waitCondition(condition, callback, ...)
    local params = {...}
    function waitConditionCoroutine()
        repeat
            coroutine.yield(0)
        until (condition(unpack(params)) == true)
        callback(unpack(params))
        return 1
    end
    startLuaCoroutine(self, 'waitConditionCoroutine')
end

function conditionOr(...)
    local conditions = {...}
    function conditionOrInstance()
        for index, condition in pairs(conditions) do
            if (condition()) then
                return true
            end
        end
        return false
    end
    return conditionOrInstance
end

function conditionTime(seconds)
    local awaitSeconds = os.clock() + seconds
    function conditionTimeInstance()
        return os.clock() >= awaitSeconds
    end
    return conditionTimeInstance
end

function wait(seconds, callback, ...)
    local params = {...}
    waitCondition(conditionTime(seconds), function(params)
        callback(unpack(params))
    end, params)
end

function wait2(seconds, callback, ...)
    local params = {...}
    function wait2Coroutine()
        local awaitSeconds = os.clock() + seconds
        repeat
            coroutine.yield(0)
        until (os.clock() >= awaitSeconds)
        callback(unpack(params))
        return 1
    end
    startLuaCoroutine(self, 'wait2Coroutine')
end
-- end of wait

function exportObjectToDataIfNeed(object)
    if
        isNeedExportByGuid(object.guid, data)
        and isNeedExportByObject(object, data)
    then
        exportObjectToData(object)
        return true
    end
    return false
end

-- start of exchange data block
function exportObjectToData(object)
    local percent = string.format('%.1f %%', async.progress * 100)
    self.editButton({
        index          = 0,
        label          = percent,
        tooltip        = async.progressCount
    })

    local guid = object.getGUID()
    data[guid] = {
        guid = guid,
        name = object.getName(),
        description = object.getDescription()
    }
end

function importDataToObject(object)
    local percent = string.format('%.1f %%', async.progress * 100)
    self.editButton({
        index          = 1,
        label          = percent,
        tooltip        = async.progressCount
    })

    local fields = data[object.getGUID()]
    if (fields == nil) then
        return false
    end
    object.setName(fields.name)
    object.setDescription(fields.description)
    return true
end
-- end of exchange data block

function isNeedExportByGuid(guid, data)
    -- self
    if (guid == self.guid) then
        return false
    end
    -- already processed
    if (data[guid] ~= nil) then
        return false
    end
    return true
end

function isNeedExportByObject(object, data)
    -- empty values
    local name = object.getName()
    local description = object.getDescription()
    if
        config.exportEmptyData == false
        and isEmpty(name) == true
        and isEmpty(description) == true
    then
        return false
    end
    return true
end

function importData()
    if (async.inProcess == true) then
        print('WARN: async task already started')
        return
    end
    print('Start importing...')

    syncTabs()
    local dataTab = getTabByName(dataTabName)
    local parsedData = readDataFromTab(dataTab)
    local backup = createBackupForData(parsedData)

    if (config.createImportBackups == true) then
        local tabName = createImportBackupTab(backup, importBackupTabNamePrefix)
        print('Data backuped to tab "' .. tabName .. '".')
    else
        print('Backup is disabled.')
    end

    asyncImportStart(parsedData)
end

function asyncImportStart(parsedData)
    print('Export started.')
    data = parsedData

    asyncStart(importDataToObject, asyncImportStop)
end

function asyncImportStop(count)
    print(count .. ' in-game objects imported.')

    self.editButton({
        index          = 1,
        label          = importButtonLabel,
        tooltip        = importButtonTooltip
    })

    data = nil
    print('Import done.')
end

function createBackupForData(data)
    local backup = {}
    for guid, fields in pairs(data) do
        local obj = getObjectFromGUID(guid)
        if (obj ~= nil) then
            backup[guid] = {
                guid = obj.getGUID(),
                name = obj.getName(),
                description = obj.getDescription()
            }
        end
    end
    return backup
end

function createImportBackupTab(backup, tabNamePrefix)
    local tabName = tabNamePrefix .. '_' .. os.date('%Y-%m-%d_%H:%M:%S')
    local content = JSON.encode_pretty(backup)
    addNotebookTab({
        title = tabName,
        body  = content,
        color = tabsColor
    })
    return tabName
end

function objectsComparator(o1, o2)
    return o1.guid < o2.guid
end

function objectsFieldsComparator(o1, o2)
    return o1.guid < o2.guid
end

function isEmpty(str)
    if str == nil then
        return true
    end
    if string.len(str) == 0 then
        return true
    end
    return false
end

function length(table)
    local count = 0
    for _ in pairs(table) do
        count = count + 1
    end
    return count
end

function clone (t) -- deep-copy a table
    if type(t) ~= "table" then
        return t
    end
    local meta = getmetatable(t)
    local target = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            target[k] = clone(v)
        else
            target[k] = v
        end
    end
    setmetatable(target, meta)
    return target
end

function createButtons()
    self.createButton({
        click_function = 'exportData',
        function_owner = self,
        label          = exportButtonLabel,
        position       = {0.3, 0.5, 0.3},
        rotation       = {0, 180, 0},
        -- scale          = -- Vector,
        width          = 150,
        height         = 100,
        font_size      = 40,
        color          = defaultButtonColor,
        -- font_color     = -- Color,
        tooltip        = exportButtonTooltip,
    })
    self.createButton({
        click_function = 'importData',
        function_owner = self,
        label          = importButtonLabel,
        position       = {0.3, 0.5, 0},
        rotation       = {0, 180, 0},
        -- scale          = -- Vector,
        width          = 150,
        height         = 100,
        font_size      = 40,
        color          = defaultButtonColor,
        -- font_color     = -- Color,
        tooltip        = importButtonTooltip,
    })
    self.createButton({
        click_function = 'asyncStop',
        function_owner = self,
        label          = 'Stop',
        position       = {0, 0.5, 0.3},
        rotation       = {0, 180, 0},
        -- scale          = -- Vector,
        width          = 150,
        height         = 100,
        font_size      = 40,
        color          = defaultButtonColor,
        -- font_color     = -- Color,
        tooltip        = 'Stop process of export or import',
    })
end

